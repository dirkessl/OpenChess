<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Board</title>
    <link rel="icon" type="image/svg+xml" href="./favicon.svg">
    <link rel="stylesheet" href="./css/styles.css">
    <link rel="stylesheet" href="./css/chessboard-1.0.0.min.css">
    <script src="./scripts/jquery-4.0.0.min.js"></script>
    <script src="./scripts/chessboard-1.0.0.min.js"></script>
</head>

<body>
    <!-- Audio elements for move sounds -->
    <audio id="moveSound" src="./sounds/move.mp3" preload="auto"></audio>
    <audio id="captureSound" src="./sounds/capture.mp3" preload="auto"></audio>

    <!-- Settings popup overlay -->
    <div id="settingsPopup" class="settings-overlay">
        <div class="settings-popup">
            <h3>
                <span>‚öôÔ∏è Settings</span>
                <button class="settings-close-btn" id="closeSettings">√ó</button>
            </h3>

            <div class="settings-group">
                <label>Display</label>
                <div class="settings-row">
                    <span>Show board notation</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="settingNotation" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

            <div class="settings-group">
                <label>Sound</label>
                <div class="settings-row">
                    <span>Play move sounds</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="settingSound" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

            <div class="settings-group">
                <label>Board Colors</label>
                <div class="color-picker-group">
                    <div class="color-picker-item">
                        <input type="color" id="settingLightColor" value="#f0d9b5">
                        <span>Light</span>
                    </div>
                    <div class="color-picker-item">
                        <input type="color" id="settingDarkColor" value="#b58863">
                        <span>Dark</span>
                    </div>
                    <button id="resetColorsBtn" class="fen-btn" title="Reset to default">‚Üª</button>
                </div>
            </div>

            <div class="settings-group">
                <label>Piece Theme</label>
                <div class="piece-theme-row">
                    <select id="settingPieceTheme">
                        <option value="/pieces/{piece}.svg">Local SVG (default)</option>
                        <option value="https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png">Wikipedia
                        </option>
                        <option value="https://chessboardjs.com/img/chesspieces/alpha/{piece}.png">Alpha</option>
                    </select>
                    <button id="addThemeBtn" class="fen-btn" title="Add custom theme">+</button>
                    <button id="deleteThemeBtn" class="fen-btn" title="Delete custom theme"
                        style="display:none;">‚àí</button>
                </div>
                <a id="themeUrlDisplay" class="theme-url-display" href="#" target="_blank"></a>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Chess Board</h2>

        <!-- Chess board wrapper -->
        <div class="board-wrapper">
            <div id="board" class="chessboard-container"></div>

            <!-- Control buttons in margin above board -->
            <div class="board-controls-left">
                <button id="flipBtn" class="board-ctrl-btn" title="Flip board">‚áÖ</button>
                <button id="focusBtn" class="board-ctrl-btn" title="Focus mode">‚õ∂</button>
            </div>
            <div class="board-controls-right">
                <button id="settingsBtn" class="board-ctrl-btn" title="Settings">‚öô</button>
            </div>
        </div>

        <!-- Evaluation bar (hidden in edit mode) -->
        <div class="info" id="eval-container">
            <div class="eval-bar-container">
                <div id="eval-bar"></div>
                <div id="eval-text">--</div>
            </div>
        </div>

        <!-- Edit mode instructions (above board, hidden on interaction) -->
        <div class="status anim-panel" id="edit-instructions">
            Drag pieces to edit the board
        </div>

        <!-- FEN display/edit section (shown in edit mode) -->
        <div id="fen-section" class="config-panel anim-panel">

            <!-- Edit controls -->
            <div class="controls controls-sm game-options">
                <button id="sync-btn" class="button" style="background-color: #6c757d;">‚ü≥ Sync</button>
                <button id="start-btn" class="button" style="background-color: #17a2b8;">‚Üª Reset</button>
                <button id="clear-btn" class="button" style="background-color: #dc3545;">‚úï Clear</button>
            </div>

            <!-- Turn and Castling controls -->
            <div class="game-options">
                <div class="option-group">
                    <label>Turn</label>
                    <div class="toggle-group">
                        <button id="turn-white" class="toggle-btn active">White</button>
                        <button id="turn-black" class="toggle-btn">Black</button>
                    </div>
                </div>
                <div class="option-group">
                    <label>Castling</label>
                    <div class="castling-toggles">
                        <button id="castle-K" class="castle-btn active" title="White King-side">K</button>
                        <button id="castle-Q" class="castle-btn active" title="White Queen-side">Q</button>
                        <button id="castle-k" class="castle-btn active" title="Black King-side">k</button>
                        <button id="castle-q" class="castle-btn active" title="Black Queen-side">q</button>
                    </div>
                </div>
            </div>

            <!-- FEN input and copy/edit buttons -->
            <div class="fen-container">
                <input type="text" id="fen-input" readonly>
                <button id="fen-copy-btn" class="fen-btn" title="Copy FEN">üìã</button>
                <button id="fen-edit-btn" class="fen-btn" title="Edit FEN">‚úèÔ∏è</button>
            </div>

            <!-- Apply button to send to server -->
            <button id="apply-btn" class="button" style="background-color: #28a745; margin-bottom: 0">
                ‚úì Apply Changes
            </button>
        </div>

        <!-- Mode toggle button -->
        <button id="modeToggleBtn" class="button">Edit Board</button>

        <a href="/" class="back-button">OpenChess Home</a>
    </div>

    <script>
        // State variables
        let board = null;
        let editMode = false;
        let currentTurn = 'w';
        let castlingRights = { K: true, Q: true, k: true, q: true };
        let enPassantSquare = '-';
        let halfmoveClock = 0;
        let fullmoveNumber = 1;
        let previousValidFen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';
        let isEditingFen = false;
        let updateInterval = null;
        let instructionsHidden = false;
        let boardOrientation = 'white';
        let focusMode = false;
        let previousPosition = null;

        // Settings (loaded from localStorage)
        let settings = {
            showNotation: true,
            playSound: true,
            lightSquareColor: '#f0d9b5',
            darkSquareColor: '#b58863',
            pieceTheme: '/pieces/{piece}.svg',
            customThemes: []
        };

        // Default piece themes
        const defaultThemes = [
            { value: '/pieces/{piece}.svg', label: 'Local SVG (default)' },
            { value: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png', label: 'Wikipedia' },
            { value: 'https://chessboardjs.com/img/chesspieces/alpha/{piece}.png', label: 'Alpha' }
        ];

        // Load settings from localStorage
        function loadSettings() {
            const saved = localStorage.getItem('chessBoardSettings');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    settings = { ...settings, ...parsed };
                } catch (e) {
                    console.log('Failed to parse settings');
                }
            }
            applySettings();
        }

        // Save settings to localStorage
        function saveSettings() {
            localStorage.setItem('chessBoardSettings', JSON.stringify(settings));
            applySettings();
        }

        // Apply settings to UI
        function applySettings() {
            // Update settings UI
            $('#settingNotation').prop('checked', settings.showNotation);
            $('#settingSound').prop('checked', settings.playSound);
            $('#settingLightColor').val(settings.lightSquareColor);
            $('#settingDarkColor').val(settings.darkSquareColor);

            // Update piece theme dropdown
            updatePieceThemeDropdown();
            $('#settingPieceTheme').val(settings.pieceTheme);
            updateThemeUI();

            // Apply board colors
            applyBoardColors();
        }

        // Update piece theme dropdown with default and custom themes
        function updatePieceThemeDropdown() {
            const select = $('#settingPieceTheme');
            select.empty();

            // Add default themes
            defaultThemes.forEach(theme => {
                select.append($('<option>', { value: theme.value, text: theme.label }));
            });

            // Add custom themes
            if (settings.customThemes && settings.customThemes.length > 0) {
                settings.customThemes.forEach(theme => {
                    select.append($('<option>', { value: theme.value, text: theme.label, 'data-custom': 'true' }));
                });
            }

            updateThemeUI();
        }

        // Update theme URL display and delete button visibility
        function updateThemeUI() {
            const selectedValue = settings.pieceTheme;
            const isCustom = isCustomTheme(selectedValue);

            // Show/hide delete button
            $('#deleteThemeBtn').toggle(isCustom);

            // Update URL display with clickable link
            const urlDisplay = $('#themeUrlDisplay');
            urlDisplay.text(selectedValue);
            // Replace {piece} with wN (white knight) for preview link
            const previewUrl = selectedValue.replace('{piece}', 'wN');
            urlDisplay.attr('href', previewUrl);
        }

        // Check if a theme is custom (not in default themes)
        function isCustomTheme(themeValue) {
            return !defaultThemes.some(t => t.value === themeValue);
        }

        // Apply board colors dynamically (including notation)
        function applyBoardColors() {
            // Remove existing style if present
            $('#boardColorStyle').remove();

            // Notation text color is set via the square's color property
            // Light squares have dark text, dark squares have light text for contrast
            const style = `
                <style id="boardColorStyle">
                    .white-1e1d7 { 
                        background-color: ${settings.lightSquareColor} !important; 
                        color: ${settings.darkSquareColor} !important;
                    }
                    .black-3c85d { 
                        background-color: ${settings.darkSquareColor} !important; 
                        color: ${settings.lightSquareColor} !important;
                    }
                </style>
            `;
            $('head').append(style);
        }

        // Play sound effect
        function playMoveSound(isCapture) {
            if (!settings.playSound) return;

            const sound = isCapture ? document.getElementById('captureSound') : document.getElementById('moveSound');
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(() => { });
            }
        }

        // Detect if a move is a capture by comparing positions
        function detectCapture(oldPos, newPos) {
            // Count pieces in old and new positions
            const oldCount = Object.keys(oldPos || {}).length;
            const newCount = Object.keys(newPos || {}).length;
            return newCount < oldCount;
        }

        // Custom piece theme using settings
        function pieceTheme(piece) {
            return settings.pieceTheme.replace('{piece}', piece);
        }

        // Initialize the board in view mode
        function initBoard() {
            const config = {
                draggable: false,
                position: 'start',
                pieceTheme: pieceTheme,
                showNotation: settings.showNotation,
                orientation: boardOrientation
            };
            board = Chessboard('board', config);
            $(window).on('resize', board.resize);
            applyBoardColors();
        }

        // Switch to edit mode
        function enableEditMode() {
            editMode = true;
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }

            const currentPosition = board.position();

            board.destroy();
            board = Chessboard('board', {
                draggable: true,
                dropOffBoard: 'trash',
                sparePieces: true,
                position: currentPosition,
                pieceTheme: pieceTheme,
                showNotation: settings.showNotation,
                orientation: boardOrientation,
                onChange: onBoardChange
            });

            applyBoardColors();

            // Prevent page scrolling when dragging pieces on touch devices
            $('#board').on('touchmove', function (e) {
                if ($(e.target).closest('.piece-417db').length) {
                    e.preventDefault();
                }
            });

            $('#modeToggleBtn').text('View Board');
            $('#eval-container').hide();
            if (!instructionsHidden) {
                $('#edit-instructions').addClass('visible');
            }
            $('#fen-section').addClass('visible');

            updateFenDisplay();
        }

        // Switch to view mode
        function enableViewMode() {
            editMode = false;

            const currentPosition = board.position();

            board.destroy();
            board = Chessboard('board', {
                draggable: false,
                position: currentPosition,
                pieceTheme: pieceTheme,
                showNotation: settings.showNotation,
                orientation: boardOrientation
            });

            applyBoardColors();

            $('#board').off('touchmove');

            $('#modeToggleBtn').text('Edit Board');
            $('#eval-container').show();
            $('#edit-instructions').removeClass('visible');
            $('#fen-section').removeClass('visible');

            // Resume polling after short delay to allow things to hide smoothly and
            // To allow the server FEN to be already updated on the first fetch
            setTimeout(() => { startPolling(); }, 250);
        }

        // Board change handler - immediately update FEN display after any board change
        function onBoardChange(oldPos, newPos) {
            // Permanently hide instructions when board is interacted with
            if (!instructionsHidden) {
                instructionsHidden = true;
                $('#edit-instructions').removeClass('visible');
            }

            // Play sound for piece movement in edit mode
            const isCapture = detectCapture(oldPos, newPos);
            playMoveSound(isCapture);

            // Detect pawn double moves for en passant
            enPassantSquare = '-';

            // Find what changed between old and new position
            const files = 'abcdefgh';
            for (let f = 0; f < 8; f++) {
                for (let r = 1; r <= 8; r++) {
                    const sq = files[f] + r;
                    const oldPiece = oldPos[sq];
                    const newPiece = newPos[sq];

                    // Check if a pawn appeared on rank 4 (white) or rank 5 (black)
                    if (!oldPiece && newPiece) {
                        // White pawn on rank 4, check if it came from rank 2
                        if (newPiece === 'wP' && r === 4) {
                            const fromSq = files[f] + '2';
                            if (oldPos[fromSq] === 'wP' && !newPos[fromSq]) {
                                enPassantSquare = files[f] + '3';
                            }
                        }
                        // Black pawn on rank 5, check if it came from rank 7
                        if (newPiece === 'bP' && r === 5) {
                            const fromSq = files[f] + '7';
                            if (oldPos[fromSq] === 'bP' && !newPos[fromSq]) {
                                enPassantSquare = files[f] + '6';
                            }
                        }
                    }
                }
            }

            // Use setTimeout to ensure board.fen() returns updated position
            setTimeout(updateFenDisplay, 0);
        }

        // Generate full FEN from board position and game state
        function getFullFen() {
            const positionFen = board.fen();
            const turn = currentTurn;

            let castling = '';
            if (castlingRights.K) castling += 'K';
            if (castlingRights.Q) castling += 'Q';
            if (castlingRights.k) castling += 'k';
            if (castlingRights.q) castling += 'q';
            if (castling === '') castling = '-';

            return positionFen + ' ' + turn + ' ' + castling + ' ' + enPassantSquare + ' ' + halfmoveClock + ' ' + fullmoveNumber;
        }

        // Parse full FEN and update UI state
        function parseFullFen(fen, playSound = true) {
            const parts = fen.trim().split(/\s+/);
            if (parts.length < 1) return false;

            const positionFen = parts[0];

            if (!isValidPositionFen(positionFen)) return false;

            // Get old position before updating
            const oldPosition = board ? board.position() : null;

            board.position(positionFen);

            // Get new position after updating
            const newPosition = board.position();

            // Play sound if position changed and sounds enabled
            if (playSound && oldPosition && previousValidFen !== positionFen) {
                const isCapture = detectCapture(oldPosition, newPosition);
                playMoveSound(isCapture);
            }

            previousValidFen = positionFen;

            if (parts.length >= 2) {
                currentTurn = parts[1] === 'b' ? 'b' : 'w';
                updateTurnButtons();
            }

            if (parts.length >= 3) {
                const castleStr = parts[2];
                castlingRights = {
                    K: castleStr.includes('K'),
                    Q: castleStr.includes('Q'),
                    k: castleStr.includes('k'),
                    q: castleStr.includes('q')
                };
                updateCastlingButtons();
            }

            if (parts.length >= 4) {
                enPassantSquare = parts[3];
            } else {
                enPassantSquare = '-';
            }

            if (parts.length >= 5) {
                halfmoveClock = parseInt(parts[4]) || 0;
            } else {
                halfmoveClock = 0;
            }

            if (parts.length >= 6) {
                fullmoveNumber = parseInt(parts[5]) || 1;
            } else {
                fullmoveNumber = 1;
            }

            updateEnPassantHighlight();
            return true;
        }

        // Validate position FEN (just the board part)
        function isValidPositionFen(fen) {
            if (!fen || typeof fen !== 'string') return false;

            const ranks = fen.split('/');
            if (ranks.length !== 8) return false;

            const validPieces = 'prnbqkPRNBQK';

            for (const rank of ranks) {
                let squares = 0;
                for (const char of rank) {
                    if (char >= '1' && char <= '8') {
                        squares += parseInt(char);
                    } else if (validPieces.includes(char)) {
                        squares += 1;
                    } else {
                        return false;
                    }
                }
                if (squares !== 8) return false;
            }

            return true;
        }

        // Helper function to get piece at a specific square
        function getPieceAt(fen, file, rank) {
            // file: 0-7 (a-h), rank: 0-7 (8-1 in chess notation)
            const ranks = fen.split('/');
            if (rank < 0 || rank > 7) return null;

            const rankStr = ranks[rank];
            let fileIndex = 0;

            for (const char of rankStr) {
                if (char >= '1' && char <= '8') {
                    fileIndex += parseInt(char);
                } else {
                    if (fileIndex === file) return char;
                    fileIndex++;
                }
            }
            return null;
        }

        // Validate chess position is legal (both kings present, valid king count, castling, en passant, etc.)
        function isLegalPosition(fullFen) {
            const parts = fullFen.trim().split(/\s+/);
            if (parts.length < 4) return { valid: false, error: 'Incomplete FEN notation' };

            const fen = parts[0];
            const turn = parts[1];
            const castling = parts[2];
            const enPassant = parts[3];

            if (!isValidPositionFen(fen)) return { valid: false, error: 'Invalid FEN format' };

            const position = fen.split('/').join('');

            // Count pieces
            const whiteKings = (position.match(/K/g) || []).length;
            const blackKings = (position.match(/k/g) || []).length;
            const whiteQueens = (position.match(/Q/g) || []).length;
            const blackQueens = (position.match(/q/g) || []).length;
            const whiteRooks = (position.match(/R/g) || []).length;
            const blackRooks = (position.match(/r/g) || []).length;
            const whiteBishops = (position.match(/B/g) || []).length;
            const blackBishops = (position.match(/b/g) || []).length;
            const whiteKnights = (position.match(/N/g) || []).length;
            const blackKnights = (position.match(/n/g) || []).length;
            const whitePawns = (position.match(/P/g) || []).length;
            const blackPawns = (position.match(/p/g) || []).length;

            // Must have exactly one king per side
            if (whiteKings !== 1) return { valid: false, error: 'White must have exactly one king' };
            if (blackKings !== 1) return { valid: false, error: 'Black must have exactly one king' };

            // Check max pieces (accounting for promotions: 8 pawns can become other pieces)
            if (whiteQueens > 9) return { valid: false, error: 'Too many white queens' };
            if (blackQueens > 9) return { valid: false, error: 'Too many black queens' };
            if (whiteRooks > 10) return { valid: false, error: 'Too many white rooks' };
            if (blackRooks > 10) return { valid: false, error: 'Too many black rooks' };
            if (whiteBishops > 10) return { valid: false, error: 'Too many white bishops' };
            if (blackBishops > 10) return { valid: false, error: 'Too many black bishops' };
            if (whiteKnights > 10) return { valid: false, error: 'Too many white knights' };
            if (blackKnights > 10) return { valid: false, error: 'Too many black knights' };
            if (whitePawns > 8) return { valid: false, error: 'Too many white pawns' };
            if (blackPawns > 8) return { valid: false, error: 'Too many black pawns' };

            // Check total piece count (max 16 per side)
            const whitePieces = whiteKings + whiteQueens + whiteRooks + whiteBishops + whiteKnights + whitePawns;
            const blackPieces = blackKings + blackQueens + blackRooks + blackBishops + blackKnights + blackPawns;
            if (whitePieces > 16) return { valid: false, error: 'Too many white pieces' };
            if (blackPieces > 16) return { valid: false, error: 'Too many black pieces' };

            // Check pawns not on first or last rank
            const ranks = fen.split('/');
            if (ranks[0].match(/[Pp]/) || ranks[7].match(/[Pp]/)) {
                return { valid: false, error: 'Pawns cannot be on the first or last rank' };
            }

            // Validate turn
            if (turn !== 'w' && turn !== 'b') {
                return { valid: false, error: 'Turn must be "w" or "b"' };
            }

            // Validate castling rights
            if (castling !== '-' && !/^[KQkq]{1,4}$/.test(castling)) {
                return { valid: false, error: 'Invalid castling rights format' };
            }

            // Check castling rights consistency with piece positions
            if (castling.includes('K')) {
                // White kingside: King on e1, Rook on h1
                if (getPieceAt(fen, 4, 7) !== 'K') {
                    return { valid: false, error: 'White kingside castling requires king on e1' };
                }
                if (getPieceAt(fen, 7, 7) !== 'R') {
                    return { valid: false, error: 'White kingside castling requires rook on h1' };
                }
            }
            if (castling.includes('Q')) {
                // White queenside: King on e1, Rook on a1
                if (getPieceAt(fen, 4, 7) !== 'K') {
                    return { valid: false, error: 'White queenside castling requires king on e1' };
                }
                if (getPieceAt(fen, 0, 7) !== 'R') {
                    return { valid: false, error: 'White queenside castling requires rook on a1' };
                }
            }
            if (castling.includes('k')) {
                // Black kingside: King on e8, Rook on h8
                if (getPieceAt(fen, 4, 0) !== 'k') {
                    return { valid: false, error: 'Black kingside castling requires king on e8' };
                }
                if (getPieceAt(fen, 7, 0) !== 'r') {
                    return { valid: false, error: 'Black kingside castling requires rook on h8' };
                }
            }
            if (castling.includes('q')) {
                // Black queenside: King on e8, Rook on a8
                if (getPieceAt(fen, 4, 0) !== 'k') {
                    return { valid: false, error: 'Black queenside castling requires king on e8' };
                }
                if (getPieceAt(fen, 0, 0) !== 'r') {
                    return { valid: false, error: 'Black queenside castling requires rook on a8' };
                }
            }

            // Validate en passant square
            if (enPassant !== '-') {
                if (!/^[a-h][36]$/.test(enPassant)) {
                    return { valid: false, error: 'En passant square must be on rank 3 or 6' };
                }

                const file = enPassant.charCodeAt(0) - 'a'.charCodeAt(0);
                const rank = enPassant[1];

                // If en passant is on rank 3, white pawn just moved to rank 4, so it's black's turn
                if (rank === '3') {
                    if (turn !== 'b') {
                        return { valid: false, error: 'En passant on rank 3 requires black to move' };
                    }
                    const pawnPiece = getPieceAt(fen, file, 4); // rank 4 (index 4)
                    if (pawnPiece !== 'P') {
                        return { valid: false, error: 'En passant on rank 3 requires white pawn on rank 4' };
                    }
                }
                // If en passant is on rank 6, black pawn just moved to rank 5, so it's white's turn
                else if (rank === '6') {
                    if (turn !== 'w') {
                        return { valid: false, error: 'En passant on rank 6 requires white to move' };
                    }
                    const pawnPiece = getPieceAt(fen, file, 3); // rank 5 (index 3)
                    if (pawnPiece !== 'p') {
                        return { valid: false, error: 'En passant on rank 6 requires black pawn on rank 5' };
                    }
                }
            }

            return { valid: true, error: null };
        }

        // Update en passant square highlight on the board
        function updateEnPassantHighlight() {
            // Remove any existing highlight
            $('.square-55d63').removeClass('highlight-ep');

            // Only show highlight in edit mode
            if (editMode && enPassantSquare !== '-' && /^[a-h][1-8]$/.test(enPassantSquare)) {
                $('.square-' + enPassantSquare).addClass('highlight-ep');
            }
        }

        // Update FEN input display
        function updateFenDisplay() {
            if (!isEditingFen) {
                $('#fen-input').val(getFullFen());
            }
            updateEnPassantHighlight();
        }

        // Update turn toggle buttons
        function updateTurnButtons() {
            if (currentTurn === 'w') {
                $('#turn-white').addClass('active');
                $('#turn-black').removeClass('active');
            } else {
                $('#turn-white').removeClass('active');
                $('#turn-black').addClass('active');
            }
        }

        // Update castling toggle buttons
        function updateCastlingButtons() {
            ['K', 'Q', 'k', 'q'].forEach(right => {
                if (castlingRights[right]) {
                    $('#castle-' + right).addClass('active');
                } else {
                    $('#castle-' + right).removeClass('active');
                }
            });
        }

        // Update evaluation bar
        function updateEvaluationBar(evalValue) {
            const evalInPawns = evalValue.toFixed(2);
            const maxEval = 10;
            const clampedEval = Math.max(-maxEval, Math.min(maxEval, evalValue));
            const whitePercentage = ((clampedEval + maxEval) / (maxEval * 2)) * 100;

            const bar = document.getElementById('eval-bar');
            const text = document.getElementById('eval-text');

            bar.style.width = whitePercentage + '%';

            let evalText = '';
            let textColor = '#A0A0A0';

            if (evalValue > 0.5) {
                evalText = '+' + evalInPawns;
                textColor = '#000000';
            } else if (evalValue < -0.5) {
                evalText = evalInPawns;
                textColor = '#FFFFFF';
            } else {
                evalText = evalInPawns;
                textColor = '#A0A0A0';
            }

            text.textContent = evalText;
            text.style.color = textColor;
        }

        // Fetch board state from server
        function fetchBoardState() {
            if (editMode) return;

            fetch('/board-update')
                .then(response => response.json())
                .then(data => {
                    if (data.fen) {
                        parseFullFen(data.fen);
                    }
                    if (data.evaluation !== undefined) {
                        updateEvaluationBar(data.evaluation);
                    }
                })
                .catch(error => {
                    console.log('Fetch failed:', error);
                });
        }

        // Start polling for updates
        function startPolling() {
            if (updateInterval) clearInterval(updateInterval);
            fetchBoardState();
            updateInterval = setInterval(fetchBoardState, 500);
        }

        // Send edited board to server
        function applyChanges() {
            const fen = getFullFen();

            // Validate position before sending (pass full FEN for complete validation)
            const validation = isLegalPosition(fen);
            if (!validation.valid) {
                alert('Invalid position: ' + validation.error);
                return;
            }

            fetch('/board-update', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: 'fen=' + encodeURIComponent(fen)
            })
                .then(response => {
                    if (response.ok) {
                        enableViewMode();
                    } else {
                        alert('Failed to apply changes. Please try again.');
                    }
                })
                .catch(error => {
                    alert('Network error while applying changes.');
                });
        }

        // Copy FEN to clipboard
        function copyFen() {
            const fenText = $('#fen-input').val();
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(fenText).then(function () {
                    const btn = $('#fen-copy-btn');
                    btn.text('‚úì');
                    setTimeout(function () { btn.text('üìã'); }, 1000);
                }).catch(function () {
                    fallbackCopy(fenText);
                });
            } else {
                fallbackCopy(fenText);
            }
        }

        // Fallback copy method
        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                const btn = $('#fen-copy-btn');
                btn.text('‚úì');
                setTimeout(function () { btn.text('üìã'); }, 1000);
            } catch (e) {
                alert('Failed to copy. Please select and copy manually.');
            }
            document.body.removeChild(textarea);
        }

        // Toggle FEN editing
        let fenBeforeEdit = '';
        function toggleFenEdit() {
            const fenInput = $('#fen-input');
            const editBtn = $('#fen-edit-btn');

            if (isEditingFen) {
                const newFen = fenInput.val();
                // Use strong validation
                const validation = isLegalPosition(newFen);
                if (validation.valid && parseFullFen(newFen, false)) {
                    isEditingFen = false;
                    fenInput.prop('readonly', true);
                    editBtn.text('‚úèÔ∏è');
                    updateFenDisplay();
                } else {
                    const errorMsg = validation.error || 'Invalid FEN format';
                    alert('Invalid FEN: ' + errorMsg + '. Reverting to previous position.');
                    parseFullFen(fenBeforeEdit, false);
                    isEditingFen = false;
                    fenInput.prop('readonly', true);
                    editBtn.text('‚úèÔ∏è');
                    updateFenDisplay();
                }
            } else {
                fenBeforeEdit = getFullFen();
                isEditingFen = true;
                fenInput.prop('readonly', false);
                fenInput.focus();
                editBtn.text('‚úÖ');
            }
        }

        // Sync board from server
        function syncFromServer() {
            fetch('/board-update')
                .then(response => response.json())
                .then(data => {
                    if (data.fen) {
                        parseFullFen(data.fen, false); // Don't play sound for manual sync
                        updateFenDisplay();
                    }
                })
                .catch(error => {
                    alert('Failed to sync from server.');
                });
        }

        // Event handlers
        $(document).ready(function () {
            loadSettings();
            initBoard();
            startPolling();

            $('#modeToggleBtn').on('click', function () {
                if (editMode) {
                    enableViewMode();
                } else {
                    enableEditMode();
                }
            });

            $('#turn-white').on('click', function () {
                currentTurn = 'w';
                updateTurnButtons();
                updateFenDisplay();
            });

            $('#turn-black').on('click', function () {
                currentTurn = 'b';
                updateTurnButtons();
                updateFenDisplay();
            });

            ['K', 'Q', 'k', 'q'].forEach(function (right) {
                $('#castle-' + right).on('click', function () {
                    castlingRights[right] = !castlingRights[right];
                    $(this).toggleClass('active');
                    updateFenDisplay();
                });
            });

            $('#sync-btn').on('click', function () {
                syncFromServer();
                playMoveSound(false);
            });

            $('#start-btn').on('click', function () {
                board.start();
                playMoveSound(false);
                currentTurn = 'w';
                castlingRights = { K: true, Q: true, k: true, q: true };
                enPassantSquare = '-';
                halfmoveClock = 0;
                fullmoveNumber = 1;
                updateTurnButtons();
                updateCastlingButtons();
                updateFenDisplay();
            });

            $('#clear-btn').on('click', function () {
                board.clear();
                enPassantSquare = '-';
                halfmoveClock = 0;
                fullmoveNumber = 1;
                updateFenDisplay();
                playMoveSound(false);
            });

            $('#fen-copy-btn').on('click', copyFen);
            $('#fen-edit-btn').on('click', toggleFenEdit);

            $('#fen-input').on('keypress', function (e) {
                if (e.which === 13 && isEditingFen) {
                    toggleFenEdit();
                }
            });

            $('#apply-btn').on('click', applyChanges);

            // Flip board button
            $('#flipBtn').on('click', function () {
                boardOrientation = boardOrientation === 'white' ? 'black' : 'white';
                board.orientation(boardOrientation);
            });

            // Focus mode button
            $('#focusBtn').on('click', function () {
                focusMode = !focusMode;
                $(this).toggleClass('active');
                $('body').toggleClass('focus-mode');
                if (board) {
                    setTimeout(() => board.resize(), 100);
                }
            });

            // Settings button
            $('#settingsBtn').on('click', function () {
                $('#settingsPopup').addClass('visible');
            });

            // Close settings popup
            $('#closeSettings').on('click', function () {
                $('#settingsPopup').removeClass('visible');
            });

            // Close popup when clicking outside
            $('#settingsPopup').on('click', function (e) {
                if (e.target === this) {
                    $(this).removeClass('visible');
                }
            });

            // Settings: Show notation toggle
            $('#settingNotation').on('change', function () {
                settings.showNotation = this.checked;
                saveSettings();
                rebuildBoard();
            });

            // Settings: Play sounds toggle
            $('#settingSound').on('change', function () {
                settings.playSound = this.checked;
                saveSettings();
            });

            // Settings: Light square color
            $('#settingLightColor').on('input', function () {
                settings.lightSquareColor = this.value;
                saveSettings();
            });

            // Settings: Dark square color
            $('#settingDarkColor').on('input', function () {
                settings.darkSquareColor = this.value;
                saveSettings();
            });

            // Reset colors to default
            $('#resetColorsBtn').on('click', function () {
                settings.lightSquareColor = '#f0d9b5';
                settings.darkSquareColor = '#b58863';
                saveSettings();
            });

            // Settings: Piece theme dropdown
            $('#settingPieceTheme').on('change', function () {
                settings.pieceTheme = this.value;
                saveSettings();
                rebuildBoard();
                updateThemeUI();
            });

            // Delete custom piece theme
            $('#deleteThemeBtn').on('click', function () {
                const selectedValue = $('#settingPieceTheme').val();
                if (isCustomTheme(selectedValue)) {
                    if (confirm('Delete this custom theme?')) {
                        settings.customThemes = settings.customThemes.filter(t => t.value !== selectedValue);
                        settings.pieceTheme = defaultThemes[0].value;
                        saveSettings();
                        rebuildBoard();
                    }
                }
            });

            // Add custom piece theme
            $('#addThemeBtn').on('click', function () {
                const themeUrl = prompt('Enter piece theme URL pattern:\n(Use {piece} as placeholder, e.g., https://example.com/pieces/{piece}.png)');
                if (themeUrl && themeUrl.includes('{piece}')) {
                    const themeName = prompt('Enter a name for this theme:');
                    if (themeName) {
                        if (!settings.customThemes) settings.customThemes = [];
                        settings.customThemes.push({ value: themeUrl, label: themeName });
                        settings.pieceTheme = themeUrl;
                        saveSettings();
                        rebuildBoard();
                        updateThemeUI();
                    }
                } else if (themeUrl) {
                    alert('Theme URL must contain {piece} placeholder');
                }
            });

            // ESC key to exit focus mode or close settings
            $(document).on('keydown', function (e) {
                if (e.key === 'Escape') {
                    if ($('#settingsPopup').hasClass('visible')) {
                        $('#settingsPopup').removeClass('visible');
                    } else if (focusMode) {
                        focusMode = false;
                        $('#focusBtn').removeClass('active');
                        $('body').removeClass('focus-mode');
                        if (board) {
                            setTimeout(() => board.resize(), 100);
                        }
                    }
                }
            });
        });

        // Rebuild board with current settings (for notation toggle)
        function rebuildBoard() {
            const currentPosition = board.position();
            board.destroy();

            if (editMode) {
                board = Chessboard('board', {
                    draggable: true,
                    dropOffBoard: 'trash',
                    sparePieces: true,
                    position: currentPosition,
                    pieceTheme: pieceTheme,
                    showNotation: settings.showNotation,
                    orientation: boardOrientation,
                    onChange: onBoardChange
                });
            } else {
                board = Chessboard('board', {
                    draggable: false,
                    position: currentPosition,
                    pieceTheme: pieceTheme,
                    showNotation: settings.showNotation,
                    orientation: boardOrientation
                });
            }

            applyBoardColors();
        }
    </script>
</body>

</html>